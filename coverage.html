
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/HunDunDM/key-visual/codec.go (100.0%)</option>
				
				<option value="file1">github.com/HunDunDM/key-visual/errors.go (40.0%)</option>
				
				<option value="file2">github.com/HunDunDM/key-visual/heatmap.go (59.6%)</option>
				
				<option value="file3">github.com/HunDunDM/key-visual/leveldb_storage.go (92.5%)</option>
				
				<option value="file4">github.com/HunDunDM/key-visual/main.go (0.0%)</option>
				
				<option value="file5">github.com/HunDunDM/key-visual/region.go (88.8%)</option>
				
				<option value="file6">github.com/HunDunDM/key-visual/requests.go (100.0%)</option>
				
				<option value="file7">github.com/HunDunDM/key-visual/tidb.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/binary"
        "encoding/hex"
        "strings"
)

var (
        tablePrefix     = []byte{'t'}
        recordPrefixSep = []byte("_r")
        indexPrefixSep  = []byte("_i")
)

const (
        signMask uint64 = 0x8000000000000000

        encGroupSize = 8
        encMarker    = byte(0xFF)
        encPad       = byte(0x0)
)

var pads = make([]byte, encGroupSize)

// EncodeBytes guarantees the encoded value is in ascending order for comparison,
// encoding with the following rule:
//  [group1][marker1]...[groupN][markerN]
//  group is 8 bytes slice which is padding with 0.//每8个字节
//  marker is `0xFF - padding 0 count`//减去0的个数
// For example:
//   [] -&gt; [0, 0, 0, 0, 0, 0, 0, 0, 247]
//   [1, 2, 3] -&gt; [1, 2, 3, 0, 0, 0, 0, 0, 250]
//   [1, 2, 3, 0] -&gt; [1, 2, 3, 0, 0, 0, 0, 0, 251]
//   [1, 2, 3, 4, 5, 6, 7, 8] -&gt; [1, 2, 3, 4, 5, 6, 7, 8, 255, 0, 0, 0, 0, 0, 0, 0, 0, 247]
// Refer: https://github.com/facebook/mysql-5.6/wiki/MyRocks-record-format#memcomparable-format
func EncodeBytes(data []byte) []byte <span class="cov8" title="1">{
        // Allocate more space to avoid unnecessary slice growing.
        // Assume that the byte slice size is about `(len(data) / encGroupSize + 1) * (encGroupSize + 1)` bytes,
        // that is `(len(data) / 8 + 1) * 9` in our implement.

        dLen := len(data)
        result := make([]byte, 0, (dLen/encGroupSize+1)*(encGroupSize+1))
        for idx := 0; idx &lt;= dLen; idx += encGroupSize </span><span class="cov8" title="1">{
                remain := dLen - idx
                padCount := 0
                if remain &gt;= encGroupSize </span><span class="cov8" title="1">{
                        result = append(result, data[idx:idx+encGroupSize]...)
                }</span> else<span class="cov8" title="1"> {
                        padCount = encGroupSize - remain
                        result = append(result, data[idx:]...)
                        result = append(result, pads[:padCount]...)
                }</span>

                <span class="cov8" title="1">marker := encMarker - byte(padCount)
                result = append(result, marker)</span>
        }
        <span class="cov8" title="1">return result</span>
}

// EncodeIntToCmpUint make int v to comparable uint type
func EncodeIntToCmpUint(v int64) uint64 <span class="cov8" title="1">{
        return uint64(v) ^ signMask
}</span>

// EncodeInt appends the encoded value to slice b and returns the appended slice.
// EncodeInt guarantees that the encoded value is in ascending order for comparison.
func EncodeInt(b []byte, v int64) []byte <span class="cov8" title="1">{
        var data [8]byte
        u := EncodeIntToCmpUint(v)
        binary.BigEndian.PutUint64(data[:], u)
        return append(b, data[:]...)
}</span>

// GenTableRecordPrefix composes record prefix with tableID: "t[tableID]_r".
func GenTableRecordPrefix(tableID int64) string <span class="cov8" title="1">{
        buf := make([]byte, 0, len(tablePrefix)+8+len(recordPrefixSep))
        buf = appendTableRecordPrefix(buf, tableID)
        return strings.ToUpper(hex.EncodeToString(EncodeBytes(buf)))
}</span>

// GenTableIndexPrefix composes index prefix with tableID: "t[tableID]_i".
func GenTableIndexPrefix(tableID int64, idx int64) string <span class="cov8" title="1">{
        buf := make([]byte, 0, len(tablePrefix)+8+len(indexPrefixSep)+8)
        buf = appendTableIndexPrefix(buf, tableID)
        buf = EncodeInt(buf, idx)
        return strings.ToUpper(hex.EncodeToString(EncodeBytes(buf)))
}</span>

// appendTableRecordPrefix appends table record prefix  "t[tableID]_r".
func appendTableRecordPrefix(buf []byte, tableID int64) []byte <span class="cov8" title="1">{
        buf = append(buf, tablePrefix...)
        buf = EncodeInt(buf, tableID)
        buf = append(buf, recordPrefixSep...)
        return buf
}</span>

// appendTableIndexPrefix appends table index prefix  "t[tableID]_i".
func appendTableIndexPrefix(buf []byte, tableID int64) []byte <span class="cov8" title="1">{
        buf = append(buf, tablePrefix...)
        buf = EncodeInt(buf, tableID)
        buf = append(buf, indexPrefixSep...)
        return buf
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "runtime/debug"
)

func perr(err error) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">fmt.Println(err.Error())
        debug.PrintStack()
        os.Exit(1)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "github.com/HunDunDM/key-visual/matrix"
        "sort"
        "time"
)

type Label struct {
        StartKey string    `json:"start_key"`
        EndKey   string    `json:"end_key"`
        Names    []*string `json:"labels"`
}

type Heatmap struct {
        Data   [][]interface{} `json:"data"`   // two-dimensional data matrix
        Keys   []string        `json:"keys"`   // Y-axis of heatmap
        Times  []time.Time     `json:"times"`  // X-axis of heatmap
        Labels []*Label        `json:"labels"` // the label information at the left of heatmap indicating tables
}

type MultiValue struct {
        WrittenBytes uint64 `json:"written_bytes"`
        ReadBytes    uint64 `json:"read_bytes"`
        WrittenKeys  uint64 `json:"written_keys"`
        ReadKeys     uint64 `json:"read_keys"`
}

// a storage unit of regionInfo, which needs to implement matrix.Value interface
type MultiUnit struct {
        // calculate average and maximum simultaneously
        Max     MultiValue `json:"max"`
        Average MultiValue `json:"average"`
}

// 返回两个数中的较大值
func Max(a uint64, b uint64) uint64 <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (v *MultiUnit) Split(count int) matrix.Value <span class="cov8" title="1">{
        countU64 := uint64(count)
        res := *v
        res.Average.ReadKeys /= countU64
        res.Average.ReadBytes /= countU64
        res.Average.WrittenKeys /= countU64
        res.Average.WrittenBytes /= countU64
        return &amp;res
}</span>

func (v *MultiUnit) Merge(other matrix.Value) <span class="cov8" title="1">{
        v2 := other.(*MultiUnit)
        v.Max.WrittenBytes = Max(v.Max.WrittenBytes, v2.Max.WrittenBytes)
        v.Max.WrittenKeys = Max(v.Max.WrittenKeys, v2.Max.WrittenKeys)
        v.Max.ReadBytes = Max(v.Max.ReadBytes, v2.Max.ReadBytes)
        v.Max.ReadKeys = Max(v.Max.ReadKeys, v2.Max.ReadKeys)
        v.Average.WrittenBytes = v.Average.WrittenBytes + v2.Average.WrittenBytes
        v.Average.WrittenKeys = v.Average.WrittenKeys + v2.Average.WrittenKeys
        v.Average.ReadBytes = v.Average.ReadBytes + v2.Average.ReadBytes
        v.Average.ReadKeys = v.Average.ReadKeys + v2.Average.ReadKeys
}</span>

func (v *MultiUnit) Useless(threshold uint64) bool <span class="cov8" title="1">{
        return Max(v.Max.ReadBytes, v.Max.WrittenBytes) &lt; threshold
}</span>

func (v *MultiUnit) GetThreshold() uint64 <span class="cov8" title="1">{
        return Max(v.Max.ReadBytes, v.Max.WrittenBytes)
}</span>

func (v *MultiUnit) Clone() matrix.Value <span class="cov8" title="1">{
        statUnitClone := *v
        return &amp;statUnitClone
}</span>

func (v *MultiUnit) Reset() <span class="cov8" title="1">{
        *v = MultiUnit{}
}</span>

func (v *MultiUnit) Default() matrix.Value <span class="cov8" title="1">{
        return new(MultiUnit)
}</span>

func (v *MultiUnit) Equal(other matrix.Value) bool <span class="cov0" title="0">{
        another := other.(*MultiUnit)
        return *v == *another
}</span>

// a statistics unit of single index, which needs to implement matrix.Value interface
type SingleUnit struct {
        // calculate average and maximum simultaneously
        // 0 indicates maximum mode, 1 indicates average mode
        Value uint64 `json:"value"`
        Mode  int    `json:"mode"`
}

func (v *SingleUnit) Split(count int) matrix.Value <span class="cov8" title="1">{
        countU64 := uint64(count)
        res := *v
        if v.Mode == 1 </span><span class="cov8" title="1">{
                res.Value /= countU64
        }</span>
        <span class="cov8" title="1">return &amp;res</span>
}

func (v *SingleUnit) Merge(other matrix.Value) <span class="cov8" title="1">{
        v2 := other.(*SingleUnit)
        if v.Mode == 0 </span><span class="cov8" title="1">{
                v.Value = Max(v.Value, v2.Value)
        }</span> else<span class="cov8" title="1"> {
                v.Value = v.Value + v2.Value
        }</span>
}

func (v *SingleUnit) Useless(threshold uint64) bool <span class="cov8" title="1">{
        return v.Value &lt; threshold
}</span>

func (v *SingleUnit) GetThreshold() uint64 <span class="cov8" title="1">{
        return v.Value
}</span>

func (v *SingleUnit) Clone() matrix.Value <span class="cov8" title="1">{
        statUnitClone := *v
        return &amp;statUnitClone
}</span>

func (v *SingleUnit) Reset() <span class="cov8" title="1">{
        *v = SingleUnit{
                Mode: v.Mode,
        }
}</span>

func (v *SingleUnit) Default() matrix.Value <span class="cov8" title="1">{
        return &amp;SingleUnit{
                Mode: v.Mode,
        }
}</span>

func (v *SingleUnit) Equal(other matrix.Value) bool <span class="cov8" title="1">{
        another := other.(*SingleUnit)
        return *v == *another
}</span>

func GenerateHeatmap(startTime time.Time, endTime time.Time, startKey string, endKey string, tag, mode string) *Heatmap <span class="cov8" title="1">{
        separateValue := func(unit *regionUnit) matrix.Value </span><span class="cov8" title="1">{
                var m int
                switch mode </span>{
                case "average":<span class="cov0" title="0">
                        m = 1</span>
                default:<span class="cov8" title="1">
                        m = 0</span>
                }
                <span class="cov8" title="1">var data uint64
                switch tag </span>{
                case "read_bytes":<span class="cov8" title="1">
                        data = unit.Max.ReadBytes</span>
                case "written_bytes":<span class="cov0" title="0">
                        data = unit.Max.WrittenBytes</span>
                case "read_keys":<span class="cov0" title="0">
                        data = unit.Max.ReadKeys</span>
                case "written_keys":<span class="cov0" title="0">
                        data = unit.Max.WrittenKeys</span>
                case "read_and_written_bytes":<span class="cov0" title="0">
                        data = unit.Max.ReadBytes + unit.Max.WrittenBytes</span>
                case "read_and_written_keys":<span class="cov0" title="0">
                        data = unit.Max.ReadKeys + unit.Max.WrittenKeys</span>
                default:<span class="cov0" title="0">
                        return unit.BuildMultiValue()</span>
                }
                <span class="cov8" title="1">single := &amp;SingleUnit{
                        Value: data,
                        Mode:  m,
                }
                return single</span>
        }
        <span class="cov8" title="1">rangePlane := globalRegionStore.Range(startTime, endTime, separateValue)
        if rangePlane == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // range information in key axis
        <span class="cov8" title="1">for i := 0; i &lt; len(rangePlane.Axes); i++ </span><span class="cov8" title="1">{
                tempAxis := rangePlane.Axes[i]
                if tempAxis != nil </span><span class="cov8" title="1">{
                        rangePlane.Axes[i] = tempAxis.Range(startKey, endKey)
                }</span>
        }

        <span class="cov8" title="1">newMatrix := rangePlane.Pixel(50, 80)
        heatmap := ChangeIntoHeatmap(newMatrix)
        return MatchTable(heatmap)</span>
}

func ChangeIntoHeatmap(matrix *matrix.Matrix) *Heatmap <span class="cov8" title="1">{
        if matrix == nil || len(matrix.Data) == 0 || len(matrix.Data[0]) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">heatmap := &amp;Heatmap{
                Keys:  matrix.Keys,
                Times: matrix.Times,
        }
        isMulti := true
        if _, ok := matrix.Data[0][0].(*SingleUnit); ok </span><span class="cov8" title="1">{
                isMulti = false
        }</span>
        <span class="cov8" title="1">if isMulti </span><span class="cov0" title="0">{
                n := len(matrix.Data)
                heatmap.Data = make([][]interface{}, n)
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        m := len(matrix.Data[i])
                        heatmap.Data[i] = make([]interface{}, m)
                        for j := 0; j &lt; m; j++ </span><span class="cov0" title="0">{
                                heatmap.Data[i][j] = matrix.Data[i][j]
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                n := len(matrix.Data)
                heatmap.Data = make([][]interface{}, n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        m := len(matrix.Data[i])
                        heatmap.Data[i] = make([]interface{}, m)
                        for j := 0; j &lt; m; j++ </span><span class="cov8" title="1">{
                                singleUnit := matrix.Data[i][j].(*SingleUnit)
                                heatmap.Data[i][j] = singleUnit.Value
                        }</span>
                }
        }
        <span class="cov8" title="1">return heatmap</span>
}

// match tables
func MatchTable(hmap *Heatmap) *Heatmap <span class="cov8" title="1">{
        if hmap == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">keys := hmap.Keys
        if keys == nil || len(keys) &lt; 2 </span><span class="cov0" title="0">{
                return hmap
        }</span>
        <span class="cov8" title="1">hmap.Labels = make([]*Label, 0)
        for i := 0; i &lt; len(keys)-1; i++ </span><span class="cov8" title="1">{
                hmap.Labels = append(hmap.Labels, &amp;Label{
                        StartKey: keys[i],
                        EndKey:   keys[i+1],
                        Names:    make([]*string, 0),
                })
        }</span>
        <span class="cov8" title="1">tables := loadTables()
        for _, table := range tables </span><span class="cov0" title="0">{
                dataStart := GenTableRecordPrefix(table.ID)
                dataEnd := GenTableRecordPrefix(table.ID + 1)

                start := sort.Search(len(keys), func(i int) bool </span><span class="cov0" title="0">{
                        return keys[i] &gt; dataStart
                }</span>)

                <span class="cov0" title="0">end := sort.Search(len(keys), func(i int) bool </span><span class="cov0" title="0">{
                        return keys[i] &gt;= dataEnd
                }</span>)
                <span class="cov0" title="0">if start &gt; len(keys)-1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if start &gt; 0 </span><span class="cov0" title="0">{
                        start--
                }</span>

                <span class="cov0" title="0">if end &gt;= len(keys) </span><span class="cov0" title="0">{
                        end = len(keys) - 1
                }</span>
                <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                        if dataStart &lt; hmap.Labels[i].StartKey &amp;&amp; dataEnd &gt; hmap.Labels[i].EndKey </span><span class="cov0" title="0">{
                                hmap.Labels[i].StartKey = dataStart
                                hmap.Labels[i].EndKey = dataEnd
                        }</span>
                        <span class="cov0" title="0">name := fmt.Sprintf("tidb:%s, table:%s, data", table.DB, table.Name)
                        hmap.Labels[i].Names = append(hmap.Labels[i].Names, &amp;name)</span>
                }
                <span class="cov0" title="0">for idx, idxName := range table.Indices </span><span class="cov0" title="0">{

                        indexStart := GenTableIndexPrefix(table.ID, idx)
                        indexEnd := GenTableIndexPrefix(table.ID, idx+1)
                        start := sort.Search(len(keys), func(i int) bool </span><span class="cov0" title="0">{
                                return keys[i] &gt; indexStart
                        }</span>)

                        <span class="cov0" title="0">end := sort.Search(len(keys), func(i int) bool </span><span class="cov0" title="0">{
                                return keys[i] &gt;= indexEnd
                        }</span>)

                        <span class="cov0" title="0">if start &gt; len(keys)-1 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if start &gt; 0 </span><span class="cov0" title="0">{
                                start--
                        }</span>
                        <span class="cov0" title="0">if end &gt;= len(keys) </span><span class="cov0" title="0">{
                                end = len(keys) - 1
                        }</span>

                        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                                if indexStart &lt; hmap.Labels[i].StartKey &amp;&amp; indexEnd &gt; hmap.Labels[i].EndKey </span><span class="cov0" title="0">{
                                        hmap.Labels[i].StartKey = indexStart
                                        hmap.Labels[i].EndKey = indexEnd
                                }</span>
                                <span class="cov0" title="0">name := fmt.Sprintf("tidb:%s, table:%s, index:%s", table.DB, table.Name, idxName)
                                hmap.Labels[i].Names = append(hmap.Labels[i].Names, &amp;name)</span>
                        }
                }
        }
        <span class="cov8" title="1">return hmap</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "errors"
        "github.com/pingcap/goleveldb/leveldb"
        "github.com/pingcap/goleveldb/leveldb/iterator"
)

type LeveldbStorage struct {
        *leveldb.DB
}

// NewLeveldbStorage is used to store regions information.
func NewLeveldbStorage(path string) (*LeveldbStorage, error) <span class="cov8" title="1">{
        db, err := leveldb.OpenFile(path, nil)
        if err != nil </span><span class="cov0" title="0">{
                perr(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;LeveldbStorage{db}, nil</span>
}

// Load gets a value for a given key.
func (db *LeveldbStorage) Load(key []byte) (string, error) <span class="cov8" title="1">{
        v, err := db.Get(key, nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(v), err</span>
}

// Save stores a key-value pair.
func (db *LeveldbStorage) Save(key, value []byte) error <span class="cov8" title="1">{
        return db.Put(key, value, nil)
}</span>
func (db *LeveldbStorage) Search(k []byte) iterator.Iterator <span class="cov8" title="1">{
        iter := db.NewIterator(nil, nil)
        for iter.Next() </span><span class="cov8" title="1">{
                if string(iter.Key()) &gt;= string(k) </span><span class="cov8" title="1">{
                        return iter
                }</span>
        }
        <span class="cov8" title="1">iter.Release()
        return nil</span>
}
func (db *LeveldbStorage) Traversal() (allValues []string) <span class="cov8" title="1">{
        iter := db.NewIterator(nil, nil)
        for iter.Next() </span><span class="cov8" title="1">{
                allValues = append(allValues, string(iter.Value()))
        }</span>
        <span class="cov8" title="1">iter.Release()
        return allValues</span>
}

// Range gets a range of value for a given key range.
func (db *LeveldbStorage) LoadRange(startKey, endKey []byte) ([]string, []string, error) <span class="cov8" title="1">{
        startIter := db.Search(startKey)
        endIter := db.Search(endKey)

        isEndNil := false
        if startIter == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("startTime too late")
        }</span>
        <span class="cov8" title="1">if endIter == nil </span><span class="cov8" title="1">{
                isEndNil = true
        }</span>
        <span class="cov8" title="1">iter := startIter
        keys := make([]string, 0)
        values := make([]string, 0)
        keys = append(keys, string(iter.Key()))
        values = append(values, string(iter.Value()))
        for iter.Next() </span><span class="cov8" title="1">{
                keys = append(keys, string(iter.Key()))
                values = append(values, string(iter.Value()))
                if !isEndNil &amp;&amp; string(iter.Key()) == string(endIter.Key()) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">iter.Release()
        return keys, values, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "encoding/json"
        "flag"
        "github.com/rs/cors"
        "net/http"
        "time"
)

var (
        // the IP address and port number that this server listen on
        addr = flag.String("addr", "0.0.0.0:8000", "Listening address")
        // PD Server address
        pdAddr = flag.String("pd", "http://172.16.4.191:8010", "PD address")
        // TiDB Server address
        tidbAddr = flag.String("tidb", "http://172.16.4.191:10080", "TiDB Address")
        //interval
        interval  = flag.Duration("I", 10*time.Second, "Interval to collect metrics")
)

func handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-type", "application/json")
        startKey := r.FormValue("startkey")
        endKey := r.FormValue("endkey")
        start := r.FormValue("starttime")
        end := r.FormValue("endtime")
        endTime := time.Now()
        startTime := endTime.Add(-60 * time.Minute)
        // tag indicates the type of data request(e.g. read or write)
        tag := r.FormValue("tag")
        // mode indicates the mod of data statistics(e.g. max or average)
        mode := r.FormValue("mode")

        if start != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(start); err == nil </span><span class="cov0" title="0">{
                        startTime = endTime.Add(d)
                }</span>
        }
        <span class="cov0" title="0">if end != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(end); err == nil </span><span class="cov0" title="0">{
                        endTime = endTime.Add(d)
                }</span>
        }
        <span class="cov0" title="0">if endKey == "" </span><span class="cov0" title="0">{
                endKey = "~" // \126, which is the biggest displayable character
        }</span>
        <span class="cov0" title="0">matrix := GenerateHeatmap(startTime, endTime, startKey, endKey, tag, mode)
        data, _ := json.Marshal(matrix)
        _, err := w.Write(data)
        perr(err)</span>
}

func updateStat(ctx context.Context) <span class="cov0" title="0">{
        // use ticker to get data at certain intervals
        ticker := time.NewTicker(*interval)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        regions := ScanRegions()
                        globalRegionStore.Append(regions)
                        updateTables()</span>
                }
        }
}

func main() <span class="cov0" title="0">{
        flag.Parse()
        // update data loop
        go updateStat(context.Background())
        mux := http.NewServeMux()
        mux.HandleFunc("/heatmaps", handler)

        // cors.Default() setup the middleware with default options being
        // all origins accepted with simple methods (GET, POST). See
        // documentation below for more options.
        handler := cors.Default().Handler(mux)

        _ = http.ListenAndServe(*addr, handler)
        // close the two levelDbs
        globalRegionStore.Close()
        tables.Close()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "github.com/HunDunDM/key-visual/matrix"
        "sync"
        "time"
)
const defaultRegionPath = "../storage/region"

type regionInfo struct {
        ID           uint64 `json:"id"`
        StartKey     string `json:"start_key"`
        EndKey       string `json:"end_key"`
        WrittenBytes uint64 `json:"written_bytes,omitempty"`
        ReadBytes    uint64 `json:"read_bytes,omitempty"`
        WrittenKeys  uint64 `json:"written_keys,omitempty"`
        ReadKeys     uint64 `json:"read_keys,omitempty"`
}

func ScanRegions() []*regionInfo <span class="cov8" title="1">{
        var key []byte
        var err error
        regions := make([]*regionInfo, 0, 1024)
        for </span><span class="cov8" title="1">{
                info := regionRequest(key, 1024)
                length := len(info.Regions)
                if length == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">regions = append(regions, info.Regions...)

                lastEndKey := info.Regions[length-1].EndKey
                if lastEndKey == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">key, err = hex.DecodeString(lastEndKey)
                perr(err)</span>
        }
        <span class="cov8" title="1">return regions</span>
}

type regionData struct {
        WrittenBytes uint64 `json:"written_bytes"`
        ReadBytes    uint64 `json:"read_bytes"`
        WrittenKeys  uint64 `json:"written_keys"`
        ReadKeys     uint64 `json:"read_keys"`
}

// a storage unit of region information, which needs to implement the matrix.Value interface
type regionUnit struct {
        // calculate average and maximum simultaneously
        Max     regionData `json:"max"`
        Average regionData `json:"average"`
}

func newRegionUnit(r *regionInfo) *regionUnit <span class="cov8" title="1">{
        rValue := regionData{
                WrittenBytes: r.WrittenBytes,
                ReadBytes:    r.ReadBytes,
                WrittenKeys:  r.WrittenKeys,
                ReadKeys:     r.ReadKeys,
        }
        return &amp;regionUnit{
                Max:     rValue,
                Average: rValue,
        }
}</span>

func (r *regionUnit) Merge(other *regionUnit) <span class="cov8" title="1">{
        r.Max.WrittenBytes = Max(r.Max.WrittenBytes, other.Max.WrittenBytes)
        r.Max.WrittenKeys = Max(r.Max.WrittenKeys, other.Max.WrittenKeys)
        r.Max.ReadBytes = Max(r.Max.ReadBytes, other.Max.ReadBytes)
        r.Max.ReadKeys = Max(r.Max.ReadKeys, other.Max.ReadKeys)
        r.Average.WrittenBytes = r.Average.WrittenBytes + other.Average.WrittenBytes
        r.Average.WrittenKeys = r.Average.WrittenKeys + other.Average.WrittenKeys
        r.Average.ReadBytes = r.Average.ReadBytes + other.Average.ReadBytes
        r.Average.ReadKeys = r.Average.ReadKeys + other.Average.ReadKeys
}</span>

func (r regionUnit) Useless(threshold uint64) bool <span class="cov8" title="1">{
        return Max(r.Max.ReadBytes, r.Max.WrittenBytes) &lt; threshold
}</span>

func (r regionUnit) BuildMultiValue() *MultiUnit <span class="cov8" title="1">{
        max := MultiValue{
                r.Max.WrittenBytes,
                r.Max.ReadBytes,
                r.Max.WrittenKeys,
                r.Max.ReadKeys,
        }
        average := MultiValue{
                r.Average.WrittenBytes,
                r.Average.ReadBytes,
                r.Average.WrittenKeys,
                r.Average.ReadKeys,
        }
        return &amp;MultiUnit{
                max,
                average,
        }
}</span>

// here we define another Line structure different from matrix.Line
// because that one uses a interface and cannot be encoded to json string
type Line struct {
        EndKey     string `json:"end_key"`
        RegionUnit *regionUnit `json:"region_unit"`
}

type DiscreteAxis struct {
        StartKey string    `json:"start_key"` // the first line's StartKey
        Lines    []*Line   `json:"lines"`
        EndTime  time.Time `json:"end_time"` // the last line's EndTime
}

// merge lines that have values less than threshold
// which is like eliminate the noise point in a map
func (axis *DiscreteAxis) DeNoise(threshold uint64) <span class="cov8" title="1">{
        newAxis := make([]*Line, 0)
        // a consecutive set of lines which all have values less than threshold can be merged
        // a consecutive set of lines which have values that are very close to each other can also be merged
        isLastLess := false      // indicates whether the last line's value is less than threshold
        var lastIndex int64 = -1 // the last line's index
        for _, line := range axis.Lines </span><span class="cov8" title="1">{
                if line.RegionUnit.Useless(threshold) </span><span class="cov8" title="1">{
                        if isLastLess </span><span class="cov8" title="1">{ // if the prior line's value is also less than threshold, do merge operation
                                newAxis[len(newAxis)-1].RegionUnit.Merge(line.RegionUnit)
                                newAxis[len(newAxis)-1].EndKey = line.EndKey
                        }</span> else<span class="cov8" title="1"> {
                                isLastLess = true
                                newAxis = append(newAxis, line)
                        }</span>
                } else<span class="cov8" title="1"> { // when meeting a line which has value bigger than threshold
                        isLastLess = false
                        if lastIndex == -1 || line.RegionUnit != axis.Lines[lastIndex].RegionUnit </span><span class="cov8" title="1">{
                                newAxis = append(newAxis, line)
                        }</span> else<span class="cov0" title="0"> { // means that this value is the same as the prior value
                                newAxis[len(newAxis)-1].RegionUnit.Merge(line.RegionUnit)
                                newAxis[len(newAxis)-1].EndKey = line.EndKey
                        }</span>
                }
                <span class="cov8" title="1">lastIndex++</span>
        }
        <span class="cov8" title="1">axis.Lines = newAxis</span>
}

// convert the regionInfo into key axis and insert it into Stat
func (r *RegionStore) Append(regions []*regionInfo) <span class="cov8" title="1">{
        if len(regions) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if regions[len(regions)-1].EndKey == "" </span><span class="cov0" title="0">{
                regions[len(regions)-1].EndKey = "~"
        }</span>
        // find the first regionInfo that is not nil
        <span class="cov8" title="1">firstIndex := 0
        for firstIndex &lt; len(regions) </span><span class="cov8" title="1">{
                if regions[firstIndex] != nil </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        firstIndex++
                }</span>
        }
        <span class="cov8" title="1">if firstIndex == len(regions) </span><span class="cov0" title="0">{
                return
        }</span>
        // generate DiscreteAxis firstly
        <span class="cov8" title="1">axis := &amp;DiscreteAxis{
                StartKey: regions[firstIndex].StartKey,
                EndTime:  time.Now(),
        }
        // generate lines
        for _, info := range regions </span><span class="cov8" title="1">{
                if info == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">line := &amp;Line{
                        EndKey:     info.EndKey,
                        RegionUnit: newRegionUnit(info),
                }
                axis.Lines = append(axis.Lines, line)</span>
        }
        // compress those lines that have values 0
        <span class="cov8" title="1">axis.DeNoise(1)

        value, err := json.Marshal(axis)
        perr(err)
        nowTime := make([]byte, 8)
        binary.BigEndian.PutUint64(nowTime, uint64(time.Now().Unix()))
        r.Lock()
        defer r.Unlock()
        err = r.Save(nowTime, value)
        perr(err)</span>
}

func (r *RegionStore) Range(startTime time.Time, endTime time.Time, separateValue func(r *regionUnit) matrix.Value) *matrix.DiscretePlane <span class="cov8" title="1">{
        // range information in time axis
        start := startTime.Unix()
        end := endTime.Unix()
        var startBuf = make([]byte, 8)
        var endBuf = make([]byte, 8)
        binary.BigEndian.PutUint64(startBuf, uint64(start))
        binary.BigEndian.PutUint64(endBuf, uint64(end))

        r.RLock()
        _, rangeValues, _ := r.LoadRange(startBuf, endBuf)
        r.RUnlock()
        if rangeValues == nil || len(rangeValues) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var rangeTimePlane matrix.DiscretePlane
        for _, value := range rangeValues </span><span class="cov8" title="1">{
                axis := DiscreteAxis{}
                err := json.Unmarshal([]byte(value), &amp;axis)
                perr(err)

                lines := make([]*matrix.Line, len(axis.Lines))
                for i, v := range axis.Lines </span><span class="cov8" title="1">{
                        lines[i] = &amp;matrix.Line{
                                EndKey: v.EndKey,
                                Value:  separateValue(v.RegionUnit),
                        }
                }</span>
                <span class="cov8" title="1">newAxis := matrix.DiscreteAxis{
                        StartKey: axis.StartKey,
                        Lines:    lines,
                        EndTime:  axis.EndTime,
                }
                rangeTimePlane.Axes = append(rangeTimePlane.Axes, &amp;newAxis)</span>
        }
        <span class="cov8" title="1">rangeTimePlane.StartTime = rangeTimePlane.Axes[0].EndTime.Add(-*interval)
        return &amp;rangeTimePlane</span>
}

type RegionStore struct {
        sync.RWMutex
        *LeveldbStorage
}

var globalRegionStore RegionStore

func init() <span class="cov8" title="1">{
        globalRegionStore.LeveldbStorage, _ = NewLeveldbStorage(defaultRegionPath)
        regions := []*regionInfo {
                {
                        StartKey:"",
                        EndKey:"~",
                },
        }
        // insert an empty axis, which means that from the last time the server shutdown till now the data is zero
        globalRegionStore.Append(regions)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
)

type regionsInfo struct {
        Regions []*regionInfo `json:"regions"`
}

type dbInfo struct {
        Name struct {
                O string `json:"O"`
                L string `json:"L"`
        } `json:"db_name"`
        State int `json:"state"`
}

type tableInfo struct {
        ID   int64 `json:"id"`
        Name struct {
                O string `json:"O"`
                L string `json:"L"`
        } `json:"name"`
        Indices []struct {
                ID   int64 `json:"id"`
                Name struct {
                        O string `json:"O"`
                        L string `json:"L"`
                } `json:"idx_name"`
        } `json:"index_info"`
}

func request(addr string, uri string, v interface{}) <span class="cov8" title="1">{
        resp, err := http.Get(fmt.Sprintf("%s/%s", addr, uri))
        perr(err)
        r, err := ioutil.ReadAll(resp.Body)
        perr(err)
        err = resp.Body.Close()
        perr(err)
        err = json.Unmarshal(r, v)
        perr(err)
}</span>

func regionRequest(key []byte, limit uint64) regionsInfo <span class="cov8" title="1">{
        uri := fmt.Sprintf("pd/api/v1/regions/key?key=%s&amp;limit=%d", url.QueryEscape(string(key)), limit)
        var info regionsInfo
        request(*pdAddr, uri, &amp;info)
        return info
}</span>

func dbRequest(limit uint64) []*dbInfo <span class="cov8" title="1">{
        var dbInfos = make([]*dbInfo, limit)
        request(*tidbAddr, "schema", &amp;dbInfos)
        return dbInfos
}</span>

func tableRequest(limit uint64, s string) []*tableInfo <span class="cov8" title="1">{
        var tableInfos = make([]*tableInfo, limit)
        uri := fmt.Sprintf("schema/%s", s)
        request(*tidbAddr, uri, &amp;tableInfos)
        return tableInfos
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "encoding/binary"
        "encoding/json"
        "sort"
        "sync"
)

const defaulttablePath = "../storage/table"

// Table saves the info of a table
type Table struct {
        Name string `json:"name"`
        DB   string `json:"db"`
        ID   int64  `json:"id"`

        Indices map[int64]string `json:"indices"`
}

// TableSlice is the slice of tables
type TableSlice []*Table

func (s TableSlice) Len() int      <span class="cov8" title="1">{ return len(s) }</span>
func (s TableSlice) Swap(i, j int) <span class="cov8" title="1">{ s[i], s[j] = s[j], s[i] }</span>
func (s TableSlice) Less(i, j int) bool <span class="cov8" title="1">{
        if s[i].DB &lt; s[j].DB </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> if s[i].DB == s[j].DB &amp;&amp; s[i].Name &lt; s[j].Name </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> if s[i].DB == s[j].DB &amp;&amp; s[i].Name == s[j].Name </span><span class="cov8" title="1">{
                return s[i].ID &lt; s[j].ID
        }</span>
        <span class="cov8" title="1">return false</span>
}

type TablesStore struct {
        sync.RWMutex
        *LeveldbStorage
}

func loadTables() []*Table <span class="cov8" title="1">{
        tableSlice := make([]*Table, 0)
        tables.RLock()
        allValue := tables.Traversal()
        tables.RUnlock()
        for _, v := range allValue </span><span class="cov8" title="1">{
                var table Table
                err := json.Unmarshal([]byte(v), &amp;table)
                perr(err)
                tableSlice = append(tableSlice, &amp;table)
        }</span>
        <span class="cov8" title="1">sort.Sort(TableSlice(tableSlice))
        return tableSlice</span>
}

func updateTables() <span class="cov8" title="1">{
        dbInfos := dbRequest(0)
        tables.Lock()
        defer tables.Unlock()
        for _, info := range dbInfos </span><span class="cov8" title="1">{
                if info.State == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">tblInfos := tableRequest(0, info.Name.O)

                for _, table := range tblInfos </span><span class="cov8" title="1">{
                        indices := make(map[int64]string, len(table.Indices))
                        for _, index := range table.Indices </span><span class="cov8" title="1">{
                                indices[index.ID] = index.Name.O
                        }</span>
                        <span class="cov8" title="1">newTable := &amp;Table{
                                ID:      table.ID,
                                Name:    table.Name.O,
                                DB:      info.Name.O,
                                Indices: indices,
                        }

                        value, err := json.Marshal(newTable)
                        perr(err)
                        var key = make([]byte, 8)
                        binary.BigEndian.PutUint64(key, uint64(newTable.ID))
                        err = tables.Save(key, value)
                        perr(err)</span>
                }
        }
}

var tables TablesStore

func init() <span class="cov8" title="1">{
        tables.LeveldbStorage, _ = NewLeveldbStorage(defaulttablePath)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
